% DFF template for Latex and A4 paper.
% 12pt Times New Roman on 1.5 line spacing and 2 cm margins.

% ----------------------------------------------------------------------

% Either format with
%    pdflatex projectdescription.tex
% Or if you use dvips and ps2pdf, remember to specify A4 paper:
%    latex  projectdescription
%    dvips  -ta4 projectdescription -o projectdescription.ps
%    ps2pdf -sPAPERSIZE=a4 projectdescription.ps

% ----------------------------------------------------------------------

\documentclass[fleqn,12pt]{article}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{times}
\usepackage[danish,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage{graphicx}         % For PDF figures
% \usepackage[dvips]{graphicx}  % For EPS figures, using dvips + ps2pdf

\usepackage[colorlinks=true,linkcolor=black,citecolor=black]{hyperref}
\usepackage{booktabs}

\usepackage{tikz}
\usetikzlibrary{positioning,fit}
\usetikzlibrary{shapes,backgrounds}
\usetikzlibrary{arrows,fit,automata,positioning,decorations,calc}
\usetikzlibrary{spy}
\usetikzlibrary{matrix,chains,decorations.pathreplacing}
\usepackage{pgfgantt}

\newcommand{\code}[1]{{\textsf{#1}}}

% Adding comments in the text during writing process
\newcommand{\note}[1]{{\it Note: #1}}
\newcommand{\todo}[1]{{\color{red} TODO: #1}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\alceste}[1]{{\color{green} Alceste: #1}}

% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\note}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\jens}[1]{}




%%% ZF
\usepackage{listings}
\lstset{
	columns=fullflexible,
	%        basicstyle=\ttfamily\footnotesize,
	basicstyle=\ttfamily\small,      
	%columns=fullflexible, keepspaces=true,
	numbers=left,    
	numberblanklines=false,
	captionpos=b,
	%	breaklines=true,
	escapeinside={@}{@},
	numbersep=5pt,
	language=C,
	tabsize=2,
	breakatwhitespace=true,
	breaklines=true,
	deletekeywords={for},
	%        keywordstyle=\ttfamily
	numbersep=5pt,
	xleftmargin=.10in,
	%xrightmargin=.25in
}



\begin{document}
% Empirically this seems to match MS Word's idea of 1.5 line spacing.
% DO NOT CHANGE
\setlength{\baselineskip}{1.44\baselineskip}

% ----------------------------------------------------------------------
% Enter the title of the project and your name

\begin{center}
  {\LARGE\bf DFF Project Description }\\[1ex]
  %https://dtudk.zoom.us/j/61032875012
  {\LARGE\bf Software-Defined Hardware (SDH)}\\[1ex]
  {\large Martin Schoeberl, DTU Compute}\\[1ex]
 \end{center}

% ----------------------------------------------------------------------
% Delete the instruction

%\noindent
%The length of the project description must not exceed the number of pages indicated for the specific instrument in the Call, excl. a brief list of references, whether it includes figures/tables or not. \emph{You must use Times New Roman; 12 point font size; 1.5 line spacing; and with a right, left, top and bottom margin of at least 2 cm. The requirements for font size also apply to any footnotes, tables and figure texts.}  This template is formatted accordingly. In the "Confirmation" \ section of the application form, you must confirm that your project description observes the permitted maximum length, before you can submit your application. The Council will disregard any portions of the project description that exceed the permitted maximum length. 
%
%Please note that the summary of the project should only be included in the application form (under the section "Title and scientific content"). The summary should therefore not be included in the project description.
% Delete the instruction

% ----------------------------------------------------------------------
% Begin writing your project description

%\section{Abstract for the application -- do not include in this document}
%
%Performance increase with general-purpose processors has come to a halt. We can no longer depend on Moore's Law to increase computing performance. The only way to achieve higher performance or lower energy consumption is by building domain-specific hardware accelerators. These accelerators can be built in ASICs or in FPGAs in the cloud. To efficiently design and verify those domain-specific accelerators, we need agile hardware development.
%
%
%This project aims to develop a method and concrete tools for agile hardware development. We will use tools, languages, development, and testing methods from the last decades in software development and apply them to hardware design. We aim to raise the tooling level for a digital design to increase productivity. Time for verifying (testing) of digital systems is about double the time of developing them in the first place. Therefore, this project's central focus is on applying software development testing methods to hardware development.
%
%\subsection{Popular Abstract}
%
%Digital systems are a central part of our current and future digital enhanced live. Denmark has a considerable industry in the design and development of digital systems. However, designing and verifying such digital systems becomes an ever-growing challenge. The main issue is the usage of old tools compared to tools for programming those devices. This project aims to apply tools and methods from software development to hardware development to increase productivity. Danish firms will benefit from the results of this project.



\section{Introduction and Objectives}
\label{sec:objectives}

We can no longer depend on Moore's Law to increase computing performance~\cite{dark-silicon:2011}.
Performance increase with general-purpose processors has come to a halt.
Building domain-specific hardware accelerators are the only way to achieve
higher performance or lower energy consumption~\cite{domain-hw-acc:2020}.
These accelerators can be built as chips or in field-programmable gate arrays (FPGAs).
We cannot update or patch chips. Therefore, thorough testing and verification of the design are mandatory.

We can learn from software development trends such as agile software development
to efficiently develop and verify those accelerators~\cite{agile:manifesto}.
We believe that {\bf we need to adapt to agile hardware development}~\cite{henn-patt:turing:2019}.
%
As accelerators become part of the cloud service, i.e., FPGAs in the cloud,
software developers will increasingly need to adapt critical algorithms to FPGAs to enhance performance.
%Hence, it is imperative to make accelerator design accessible for software developers.
By adapting hardware accelerator design to the methods and tools of contemporary software design,
it is possible to bridge both domains catering to a more uniform hardware/software development process.

Until a few years, the two main design languages Verilog and VHDL dominated the
design and testing of digital circuits.
%However, both languages are decades behind
%modern languages for software development.
However, digital design and testing methods and tools lag by several decades of development
compared to software development and testing.\footnote{Chris Lattner, The Golden Age of Compilers in an era of Hardware/Software co-design. Invited talk, ASPLOS 2021.}
With this project, we plan to
{\bf introduce methods inspired by software development and testing into the realm of digital design.}
This project explores the hardware construction language Chisel~\cite{chisel:dac2012} with Scala
for the design and test of digital systems.

This project aims to develop a method and concrete tools for agile hardware development.
{We will take inspiration from software development tools, languages, and testing methods
from the last decades and explore their applicability for hardware design.}
We aim to {\bf raise the tooling level for a digital design to increase productivity}.
Time for verifying (testing) digital systems is about double the time of developing
them in the first place.
Therefore, this project's central focus is on {\bf applying software
testing methods for hardware testing}.

%We will build a combination of open-source tools for verifying
%circuits described in mixed languages (VHDL, SystemVerilog, and Chisel).
%It builds on top of the Chisel hardware construction language and uses Scala to drive the verification. 

\paragraph{Hypothesis:} using tools, methods, and languages from the
software domain to describe and verify digital circuits will {\bf considerably increase the productivity}
of digital design and verification engineers.


%We will explore the testing strategy used in UVM in the context of verifying hardware described in Chisel.

%This project proposes a research project that aims at building a testing framework
%in Scala that takes the best methods from UVM and from decades of experience
%in software testing.
%The developed framework shall support mixed languages (VHDL, SystemVerilog, and Chisel)
%to be able to integrate legacy code.
%Furthermore, our aim is to build on open-source projects. Therefore, our
%work will be in open-source as well.

%\begin{itemize}
%\item Maybe more ideas: \url{https://www.youtube.com/watch?v=dbOi_Gboi_0}, \url{https://www.youtube.com/watch?v=4FCZLrauDcE}
%\item Higher-Order Hardware Design, meta-programming language and the actual hardware construction language are the same, usually Python or Perl scripts with strings
%\item Have a measurable objective (LoC UVM vs Scala, SystemVerilog vs Chisel)
%\item Chisel has all the Scala/Java tooling and libraries available, SystemVerilog is a niche language
%\item Rise level of tooling, not necessarily level of abstraction in HW description
%\item IDE
%\item Namespace with packets make it easier to combine IPs
%\item Industry issue is verification: how from Chisel to VHDL/Verilog
%\item How much ASIC design is done in DK? Revenue numbers?
%\item There are not enough HW designers and verification engineers available, so they shall be more productive
%\end{itemize}

\section{Background and State-of-the-Art}
\label{sec:background}


%\begin{itemize}
%\item Verification (check what is current praxis)
%\item cocotb
%\item See pull request for ref to constraint random generation
%\item Related work \url{http://koo.corpus.cam.ac.uk/drafts/tndjg-008-transactional-modelling-in-chisel.html}
%\item SV OOP is not available for synthesize, functional coverage, another test case could be my S4NOC, reference models are usually written in SystemC to avoid licenses cost for the SW developer
%\end{itemize}

\paragraph{Digital Design.}
VHDL and Verilog are the classic hardware description languages, first appeared in the 1980s.
SystemVerilog~\cite{SystemVerilog}, as an extension to Verilog, adds features from VHDL
for the hardware description and object-oriented features for verification.
Recent advances with SystemVerilog and Chisel \cite{chisel:dac2012, chisel:book} have
brought object-oriented programming into the digital design and verification process.
SystemVerilog has become a complex language with more than 250 keywords
and different tools supporting different subsets of the full specification.
In contrast, Chisel is a small language.
The power of Chisel comes from the embedding in Scala~\cite{Scala}.
Chisel is a ``Hardware Construction Language'' embedded in Scala and
brings object-oriented and functional programming into the world of digital design.
With Chisel on Scala we have the choice of different integrated development environments,
testing infrastructure (e.g., ScalaTest), and many free libraries.
We can organize open-source hardware components in Chisel like software
libraries at Maven servers.



\paragraph{Automatic Test Generation for Software.}
Randomized test generation has emerged as one of the most successful approaches
for assessing the correctness of software components.
Two essential techniques are \emph{fuzzing} and \emph{property-based testing}.
\emph{Fuzzing} is based on generating random test inputs and observing program
behavior (successful termination or crash); code coverage can be used to
guide the generation of random inputs \cite{takanen2018fuzzing,DBLP:journals/tse/BohmePR19,DBLP:conf/pldi/FuS17}.
Google's OSS-Fuzz project, for example, has filed over 20 000 bugs in 300 open source
projects (as of June 2020)~\cite{web:oss-fuzz}.
American fuzzy lop (AFL)~\cite{afl:repo} is a mutation-based fuzzer for software developed by researchers at Google. 
AFL uses a form of branch coverage, known as edge coverage, as a driving metric.
\emph{Property-based testing} generates random tests based on the specification of a component under observation.
Many implementations follow the idea from the seminal paper \cite{DBLP:conf/icfp/ClaessenH00}, including, e.g., ScalaCheck~\cite{nilsson2014scalacheck}.
%For example, suppose we implement a new operator \texttt{+++} for concatenating two strings:
%to check its correctness, we may want to ensure that for any two strings \texttt{a} and \texttt{b},
%the result of \texttt{a\,+++\,b} is a string whose length is the sum of \texttt{a}'s and \texttt{b}'s lengths.
%Using ScalaCheck, we may call this property \texttt{"concatLength"} and write it as:
%%
%\noindent%
%\begin{lstlisting}[language=Scala,numbers=none]
%  property("concatLength") = forAll { (a: String, b: String) =>
%    (a +++ b).length == (a.length + b.length)
%  }
%\end{lstlisting}
%%
%\noindent%
%ScalaCheck will produce sets of random strings \texttt{a} and \texttt{b}, and report an error if it finds a pair that does not satisfy \texttt{"concatLength"}. On the one hand, this technique is more refined than fuzzing, because it has an explicit notion of correctness (expressed by properties); on the other hand, it treats the software under test (like operator \texttt{+++} in the example above) as a black box, hence the random test sample may not achieve adequate coverage of the implementation.


\paragraph{Hardware Testing Methods.}

The digital design described in Chisel can be tested and verified with
ChiselTest~\cite{chisel:tester2}, a non-synthesizable testing framework for Chisel.
The \textit{Universal Verification Methodology} (UVM) was created to write test-benches on top of SystemVerilog. 
It allows creating reusable test benches (i.e., using the same test for multiple designs)~\cite{uvm2015b}.
As of 2017, UVM has been standardized as IEEE 1800.2~\cite{IEEE:18002}.
RFuzz~\cite{rfuzz2018}, led by UC Berkeley researchers, focuses on ``coverage-guided fuzz mutational testing.''
This method relies on FPGA-accelerated simulation.
RFuzz generates random bitstreams.
Trippel et al.~use AFL to apply software fuzzing to hardware~\cite{DBLP:journals/corr/abs-2102-02308}.
As hardware contains state, test input must be applied for several clock cycles to activate state transitions.
They transform the one-dimensional test input generated by AFL to a sequence of inputs applied
on sequential clock cycles. The tool detects bugs by checking invariants, described as assertions, during simulation.

%As for random program generation, the open-source RISC-V DV framework \cite{riscvdv}, built using python and SystemVerilog, is a notable existing solution. 
%However, an implementation in Scala will have the advantage of keeping all internal communications in the same language. 
%Our implementation will also not limit itself to one ISA but will provide a general infrastructure for RISC architectures and ISA definitions will be kept as libraries.
%
%Furthermore, continuous integration~\cite{duvall2007continuous} 
%implements an agile method that automatically runs manually written


\section{Research Plan}

As prerequisites, all researchers involved in this project will need to learn
languages and tools involved in the project and related work.
They will learn about the Scala programming language and ScalaCheck
(a Scala implementation of the property-based testing) on the software side.
On the hardware side,
the researchers need to get familiar with Chisel, SystemVerilog, and
UVM.

\paragraph{Scientific Challenges}
The main scientific challenge is to bring software based design and testing methods into
the hardware engineering field. The challenge is twofold: (1) we need to get classic
hardware engineers to learn modern software concepts like object-oriented and functional
programming; and (2) to teach software developers how to move an algorithm into hardware.


\paragraph{Advanced Digital Design.}
Scala with functional programming is an excellent basis for developing a methodology for
advanced digital design.
We will explore so-called hardware generators that can significantly increase the productivity of hardware designers.
A hardware generator is a program that can generate a configurable
hardware description.



%\subsection{WP2}
%\paragraph{Property-based Testing.}
%As a starting point, we will use ScalaCheck, an implementation of
%property-based testing in Scala, for hardware testing. We will invite
%hardware developers to write properties as constraints (like
%propSquare above), and then we will use ScalaCheck to validate or
%refute those constraints. Property-based testing has seen notable
%successes previously, such as in locating a long-standing concurrency
%bug in the Erlang database server~\cite{DBLP:conf/erlang/HughesB11};
%it was also used by Ericsson to test its media
%proxy~\cite{DBLP:conf/erlang/ArtsHJW06}, by Volvo to test car
%communications protocols~\cite{DBLP:conf/icst/ArtsHNS15}.





%\paragraph{Co-simulation.}
%
%\todo{A figure would be nice.}
%
%\begin{itemize}
%\item One use case for evaluation: cosimulation of a RISC-V simulator (Tommy) with an OS RISC-V HW 
%\item Ptolemy~\cite{ptolemyII-book} can be used to co-simulate the environment, supporting a model based design.
%\item Integration of C/C++ based models in the verification with Scala
%\item Java/Scala in UVM
%\item Hw/sw co-verification with Scala and so on, e.g., run an application on a SW processor model exploring some hardware artifacts (could be S4NOC)
%\item Model based design (Jan) with co-simulation
%\end{itemize}
%
%\paragraph{Assertions.}
%
%\begin{itemize}
%\item assertions during simulation
%\item Assertion ave been long part in SW, begin of C, but seldom used in HW and more complex assertions are interesting, such as when req is asserted, an ack has to become active within 5 clock cycles
%\end{itemize}

\paragraph{Hardware Fuzzing Techniques.}

%
We will develop novel methods for validating Chisel hardware designs via fuzzing
and property-based testing. The \textbf{key scientific challenges} will be
(1) the formalization of a suitable logic for expressing properties of
interest for the hardware design under test, and (2) limiting the number
of random tests needed to trigger the properties of interest, while achieving
adequate design coverage. We will develop a variant of temporal logic
\cite{Baier2008} (e.g., based on Linear Temporal Logic, LTL \cite{Pnueli1977LTL}) to
express the properties of interest, and implement a tool to translate such
properties into assertions to be checked against the hardware design under test.
We will then use such properties to drive the generation of focused randomized
tests that trigger the properties, in combination with fuzzing to increase the
overall testing coverage. We plan to extend ScalaCheck to generate
tests based on our temporal properties, and add support for hardware
fuzzing-based testing to ChiselTest~\cite{chisel:tester2}. We will also take
inspiration from Google's ClusterFuzz~\cite{web:clusterfuzz} to explore the
distribution of hardware design fuzzing over multiple of testing nodes on a
cloud.

%Unfortunately, their adaptation from the software realm to the hardware realm is far from trivial. 
%  Instead, hardware designs would be tested while running on a simulator, with decreased performance; moreover, the state space of the design can be extremely large (beyond the reach of any cloud-based systems), and naive random test may not achieve adequate coverage. Property-based testing can (in principle) mitigate the issue: the properties of interest could be used to restrict the testing space; however, there are two open problems: how to express the properties of interest for hardware designs, and how to generate test sets with adequate coverage.


\paragraph{Functional Coverage.}

Code coverage is a valuable tool for verifying digital designs
since it allows one to see which parts of their design have been tested correctly.
Besides classic code coverage, we will develop \emph{functional coverage}.
Functional coverage gives a qualitative measure, \textit{``which functionalities have been tested?"}
We will add a method to specify functional coverage points, cross-coverage, and timed
coverage. We will derive those specifications from the verification plan.
We will also use coverage metrics for the feedback loop of the fuzzing techniques.


%Treadle, which is a simulation engine for Chisel, does not contain support for measuring code coverage.
%We will added branch coverage to Treadle so that one can see which lines of
%LoFIRRTL code, the intermediate representation used inside of Treadle, were covered by a series of tests
%and then know, using that information, which multiplexer paths were tested. 
%Furthermore, we plan to map the results obtained with LoFIRRTL code back to the source Chisel description.
%This mapping can be done using treadle's internal ``source trackers'' that associate some FIRRTL lines back
%to their chisel source. Once that is done, it will be interesting to move from branch coverage to functional
%coverage, which would require a way to define \textit{functional coverage points} also known as
%\textit{coverage groups} in SystemVerilog.

%\begin{itemize}
%\item On coverage and cover points in proposal (coverage of the RTL hardware, but also on the generator (Jack's comment, see \url{https://gitter.im/freechipsproject/chisel3?at=5f63c878603d0b37f43b67f3})
%\item Also have range coverage on individual signals and the matrix of 2 or more (see UVM example).
%\end{itemize}
%


\paragraph{Verification Framework.}

We will develop an object-oriented and functional framework for verification based on hardware fuzzing in Scala.
This framework is inspired by UVM, but will leverage Scala's conciseness with the
combination of object-oriented programming with functional programming.
An initial experiment of testing the accumulator circuit of the Leros processor~\cite{leros:arcs2019}
showed that a test written with UVM was about 800 lines of code, where a Scala-based
test was around 80 lines of code~\cite{verify:chisel:2020}.
We describe the first steps towards the verification framework \emph{ChiselVerify} in~\cite{ChiselVerify:2021}.
%However, UVM supports more functionality that a plain ChiselTest in Scala.


\paragraph*{Dissemination and Publication}

Scientific results will be published and presented at international
conferences (e.g., DATE, DAC, CAV, FPL, ISCAS, FPGA) and in relevant scientific journals
and a PhD theses.
%We aim to publish in open access, to a large extent, in the gold open access model.
The results from the project will be available as open-source under the
industry-friendly BSD license.
A project web site will host the project documentation, the published papers, and the design's source code.
%We will provide unrestricted and cost-free digital access to all research and development results.
In the middle of the project, we will have a coordination workshop with the project partners.
In the end, we will organize a design and verification workshop, including a hands-on tutorial,
open to all interested companies and students from DTU and other universities.

\section{Practical Feasibility}

%The Embedded Systems Engineering section at DTU Compute provides
%the intellectual environment and the infrastructure (e.g., regression test server...) that we need for an ambitious research project.
%Furthermore, DTU Compute provides the infrastructure (e.g., an automatic test
%environment for regressions tests, web server).

%\paragraph*{Internationalization}
%
%\todo{Still waiting from SiFive for an ok for a stay.}



\paragraph*{Industrial Cooperation}

The Danish industry in digital design for ASICs and FPGAs is currently transitioning from using traditional
test benches written in VHDL and Verilog to a verification method based on constraint random
test generation with tools such as UVM. Therefore, the SDH project is just-in-time to support this
transition.
%
Following {\bf eight companies are interested in the SDH project} and support it with use cases.
Teledyne is interested in exploring Chisel for development and testing with the compatibility of VHDL and Verilog.
Microchip is interested in using Chisel to improve the design throughput and
provides a hardware use case to sort Ethernet packets according to their deadlines.
Synopsys provides tool support for the project.
WSAudiology provides a decimation filter use case.
Napatech will follow the project and offer challenges to the project.
Syosil will provide consulting and training in connection with any questions related to functional verification and UVM.
Comcores is interested in improving the throughput with SDH.
Huawei will follow the project within informal discussions.


%\paragraph*{Use Cases}
%
%We will have several non-trivial use cases from industry and from our own development to verify
%our development.
%Microchip provides the specification of a hardware sorting algorithm.
%From WSA we will use a decimation filter written in VHDL.
%From our research we will use a multicore device, a network-on-chip~\cite{s4noc:nocarc2019},
%to explore concurrent, transaction based verification.

\paragraph{International Mobility}

We agreed with Martin Berger, senior lecturer at the University of Sussex, to host the PhD
student for 6 month at the University of Sussex.

\paragraph*{Human Resources}

For the SDH project, we request funding for one PhD student.
Each of the senior researchers will contribute to the SDH research project.
%
%We intend to build a group with one PhD student, one postdoc, and
%two senior researchers at DTU.
%
%Quoted from the Diversity and Gender statement at DTU:
%``Diversity, equal treatment, and equality are integral to DTU, being an international
%university in scope and standard, and are fundamental principles underlying DTU's
%expectations of respect and equality''.
As the already named researchers are all male, we will actively search
for a female researcher for the PhD positions.
%However, the PhD position will be announced openly and men and women
%will have equal opportunities for applying.


{\bf Martin Schoeberl (MS)} is professor at DTU Compute and is the PI.
%His research interest is in computer architecture for real-time systems.
During his stay
at UCB in 2012 he picked up Chisel and brought it to DTU in research and teaching.
Martin has {\bf written the Chisel textbook}~\cite{chisel:book}\footnote{\url{http://www.imm.dtu.dk/~masca/chisel-book.html}}, which has been translated
into Chinese, Japanese, and Vietnamese.
%Martin is a {\bf member of the Technical Advisory Committee for
%Chisel} and therefore keeps the work of SDH in sync with the development of Chisel.
Martin is part of the regular Chisel developer meeting with
UC Berkeley researchers and developers from SiFive, a silicon valley startup.


{\bf Alceste Scalas (AS)} is associate professor at DTU Compute. His research interest is in formal methods and programming languages to aid design, development, and verification. He has relevant experience with the Scala programming language and has been invited to present his research at the Scala World 2019 developers' conference.
%; most of his top-level scientific publications have companion peer-reviewed software artifacts implemented in Scala.

{\bf Jan Madsen (JM)} is a professor and deputy director of DTU Compute.
His research spans methods
and tools for systems engineering of computing systems, embedded systems-on-a-chip,
Cyber-Physical Systems (Internet-of-Things), microfluidic biochips (Lab-on-Chip), and
synthetic biology (molecular computing).

{\bf Martin Berger (MB)} is senior lecturer at the University of Sussex.
He is interested in applying the results of this project to processor verification.

{\bf NN PhD}: we are looking for one PhD candidate with a background in computer engineering
with an interest in digital design and programming languages.

%\subsection*{Experimental Facilities}
%
%Development and simulation of the RTAI hardware can be
%performed on standard desktop PCs.
%For evaluation of individual design components small and cheap FPGA
%boards, that are already available, can be used. For the evaluation of the
%full system design of a switches with ANNs, we intend to buy three high-performance
%FPGA boards.
%%
%The needed software (e.g., VHDL simulation, FPGA compilation) is freely available.


%\vspace{-2mm}
\begin{table*}% [h!]
{\small
  \begin{center}
    \begin{tabular}{lccp{110mm}l}
      \toprule
      Task                   & PM  & Person    & Description                                                                                   \\
      \midrule
      Recruiting             & 1   & MS and JM & Recruiting of the PhD.                                                                    \\
      \midrule
      Prepare                & 3   & PhD      & Exploring related work on property-based testing and fuzzing, and learning Chisel and UVM.                           \\
      DigDesign               & 6   & PhD      & Developing a hardware generator methodology by using functional programming in Scala.         \\
      Framework              & 9   & PhD      & Development of an object-oriented and functional testing framework.                      \\
      Testing & 6   & PhD      & Develop property-based testing for ChiselVerify.                                                      \\
      Eval                   & 6 & PhD    & Evaluation of the tools with the industrial use cases.                                                     \\
      Thesis                 & 6   & PhD    & Thesis writing und submission.                                                                \\
      \midrule
      TeachSW                 &  2  & JM            & Make Chisel and its design methods accessible for software engineers. \\
      SpecLang                &    1 + 1   &  AS + MB & Design a specification language for property tests using temporal logic. \\
      Chapter                & 2   & MS        & Adding a chapter on verification to the Chisel book~\cite{chisel:book}.                       \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Tasks for SDH}\label{tab:packages}
}
\end{table*}





%\vspace{-5mm}
\paragraph*{Tasks, Milestones, and Timetable}


%\paragraph{MS1.} The milestone is to have a empirical study on the effectiveness of our approach. In particular,  we will consider testing  two kinds of properties. The first kind is injected faults, of which we will measure our capability in detecting the faults. Another category is the expected code behavior, on which our approach should  pass without raising  warnings. 
%
%
%\paragraph{MS2.} We will create  a database from historical  bug patterns.
%A program transformer will be implemented to convert the bug patterns
%into code specification. The generated specification for our benchmark
%should be validated by our hardware developers, with which a
%refinement step can be introduced to improve the database.
%
%\paragraph{MS3.} The milestone  is to have a list of bugs reported, and a detailed case study (whether the bugs are
%trivial, false alarms, for example) Besides, coverage statistics will
%be collected to measure comprehensiveness of our tests.


The project is divided into several tasks (Table~\ref{tab:packages}), each planned in person months (PM).
%The Gantt chart shows the project schedule.
For an assessment of the project's success, we have the following milestones:

\textbf{M1} (Month 6): The PhD student is selected and employed.

\textbf{M2} (Month 15): Tools have been learned, and initial artifacts have been developed.

\textbf{M3} (Month 30): All development has been finished, and the different components
can be used for exploration and evaluation of the results with the industrial use cases.

\textbf{M4} (Month 48): The project has finished, and one PhD theses has been handed in.

\paragraph*{Success Criteria:}
We aim to increase productivity by a factor of two. Measuring productivity
is not trivial, as it varies between developers. Therefore, we will approximate it by comparing the
lines of code of the design and test between SystemVerilog/UVM and Chisel/ChiselVerify.
Our assumption is a code reduction of 2/3 will translate to a factor of two increasing in productivity.


%%\vspace{-5mm}
%\begin{figure*}
%\centering
%\begin{ganttchart}[vgrid,hgrid,bar/.style={fill=gray},
%x unit=3mm, % horizontal squeezing
%%y unit chart=5mm, % vertical squeezing
%y unit title=8mm,y unit chart=4.5mm, milestone top shift=.15, milestone height=.2mm, % very tight format
%title label font=\footnotesize,
%bar label font=\footnotesize,
%milestone label font=\footnotesize,
%]{1}{48}
%% labels
%%\gantttitle{\textbf{\normalsize{RTAI Gantt chart}}}{42} \\
%\gantttitlelist{1,...,48}{1} \\
%% tasks, groups and milestones
%\ganttbar[name=r1]{Recruiting}{1}{6} \\
%\ganttmilestone[name=m1]{Milestone 1}{6} \\
%\ganttbar[name=t1]{UVM}{1}{9} \\
%\ganttbar[name=t2]{Prepare1}{7}{9} \\
%\ganttbar[name=t3]{Cover}{10}{15} \\
%\ganttmilestone[name=m2]{Milestone 2}{15} \\
%\ganttbar[name=t4]{Generate}{16}{21} \\
%\ganttbar[name=t41]{Framework}{22}{30} \\
%\ganttbar[name=t5]{Perpare2}{7}{9} \\
%\ganttbar[name=t6]{Spec}{10}{15} \\
%\ganttbar[name=t7]{Testing}{16}{21} \\
%\ganttbar[name=t8]{Bugbase}{22}{24} \\
%\ganttbar[name=t9]{Implement}{25}{30} \\
%\ganttmilestone[name=m3]{Milestone 3}{30} \\
%\ganttbar[name=t10]{Explore}{31}{34} \\
%\ganttbar[name=t11]{Eval}{35}{39} \\
%\ganttbar[name=t12]{Thesis}{40}{48} \\
%\ganttbar[name=t13]{TeachSW}{40}{46} \\
%\ganttbar[name=t14]{Chapter}{40}{46} \\
%\ganttmilestone[name=m4]{Milestone 4}{48}
%
%% relations
%\ganttlink{r1}{m1}
%\ganttlink{m1}{t2}
%\ganttlink{t1}{m2}
%\ganttlink{t2}{t3}
%\ganttlink{t3}{m2}
%\ganttlink{m2}{t4}
%\ganttlink{t4}{t41}
%\ganttlink{t41}{m3}
%
%\ganttlink{m1}{t5}
%\ganttlink{t5}{t6}
%\ganttlink{t6}{m2}
%\ganttlink{m2}{t7}
%\ganttlink{t7}{t8}
%\ganttlink{t8}{t9}
%\ganttlink{t9}{m3}
%\ganttlink{m3}{t10}
%\ganttlink{t10}{t11}
%\ganttlink{t11}{m4}
%\ganttlink{t12}{m4}
%\ganttlink{t13}{m4}
%
%\end{ganttchart}
%
%\caption{The Gantt chart of SDH}\label{fig:gantt}
%\end{figure*}





\newpage
\newpage
\small
\bibliographystyle{abbrv}
\bibliography{../../msbib,testing,../../chisel-uvm}

\end{document}
\newpage

\section{Notes}

\subsection{Feedback from Last Year}

\begin{itemize}
\item Hypothesis is missing
\item Not enough science
\item State-of-the art is not good, mainly description of tools
\item Scientific qualification is not high enough, especial the senior ones ???
\item Missing succes criteria
\item CV is too long (shall be 2 pages according to 4.3.1) Read also what it shall contain.
\end{itemize}

\subsection{Meeting notes}

V. Herdt, D. Grosse, H. M. Le, R. Drechsler, Verifying Instruction Set Simulators using Coverage-guided Fuzzing.

\url{https://www.informatik.uni-bremen.de/agra/doc/konf/2019DATE_Verifying_Instruction_Set_Simulators_using_Coverage-guided_Fuzzing.pdf}

Fuzzing naive does not work, we take the idea, but we apply it on a higher level (e.g., instructions)

Liqued types to improve testing

\url{http://goto.ucsd.edu/~rjhala/papers/liquid_types.html}

Sail for cosimulation

Sail to Chisel

Check also overlap with HaaS proposal

\subsection{More Notes}

\todo{Look at \url{https://github.com/chiselverify/chiselverify/wiki/Timed-Assertions}}


\end{document}

\newpage

\section{Ideas, Questions, TODOs}



\begin{itemize}
\item Include proposal from Jesper Birch (in Word document)
\item Take material from workshop paper
\item Look at the TODO list in infinit project
\item Widex is interested in Chisel, may join a DFF proposal
\item Peter Sestoft + microsoft cloud into Chisel project
\item DeepSpec or DeepSp?? end-to-end for Chisel
\item Support letter from UCB
\item External stay at UCB
\item Richard should be part of it
\item One PhD at ITU and PhD or postdoc (Lefteris at DTU)
\item Kasper n hours per week plus maybe part time Torur
\item Thomas from Microsemi on board
\item Konstantin Vinogradov <const.vin@gmail.com> from Widex is interested in a (industrial) PhD, might be a named candidate
\item Teledyn is interested
\end{itemize}

\subsection{Contacts}

%Jesper Birch <jb@napatech.com> sent a word document and is interested.
%
%Teledyne:
%
%"Rytter, Morten (INT)" <Morten.Rytter@Teledyne.com>
%
%simon.andersen@teledyne.com
%


One option would be for us to deliver test cases and discussions of what is needed for our company. 
